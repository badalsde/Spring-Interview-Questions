<h1 align="center">
  Data validation, REST Template & Versioning Conceptual Questions
</h1>


## Q1. Jack has some JSON data with two objects and each object has firstName, LastName elements, how do you validate to make sure those two objects are present and FirstName is required in json request anytime?
We can use Jakarta Bean Validation API, also known as JSR 380, for validating the JSON request in a Spring REST application. The Jakarta Bean Validation API provides a standard way of validating Java beans by using annotations.

  - To use Jakarta Bean Validation API, we need to add the dependencies to our pom.xml file
  - Create a DTO (Data Transfer Object) class that represents the JSON request. The DTO class should have two properties, firstName and lastName, with the @NotBlank annotation on firstName to ensure that it is always required.
  - In the Spring REST controller, we can use the @Valid annotation on the @RequestBody parameter to automatically validate the JSON request against the DTO class. If the validation fails, Spring will automatically return a bad request response with the validation error messages.

## Q2. How do you validate the fields in the request?
- In Spring REST, you can use Bean Validation to validate the fields in the request. Bean Validation is a standard validation framework for Java that provides a set of annotations and APIs for validating objects.
- To use Bean Validation in Spring REST, you can add validation annotations to the fields of your request object and annotate the request handler method with @Valid or @Validated to indicate that the request object should be validated.


## Q3. What is RestTemplate ?
- RestTemplate is a class in the Spring Framework that provides a convenient way to communicate with RESTful APIs over HTTP. It simplifies the process of making HTTP requests and processing the responses.
- With RestTemplate, we can send requests to remote servers, receive and process responses, and extract data from the response.
- RestTemplate can handle a variety of HTTP methods such as GET, POST, PUT, DELETE, and more.
- It also supports different data formats such as JSON, XML, and others. RestTemplate can be used in both synchronous and asynchronous ways.


## Q4. What are the ways to version an API?
URI versioning is one of the common ways to version RESTful APIs. here are different ways of achieving API versioning such as

**Version as part of the URI path:** In this approach, the version number is included in the URI path. For example, you can define two versions of an API using different URI paths:

```

@GetMapping("/v1/users")
public List<User> getAllUsersV1() {
    // return all users for version 1
}
@GetMapping("/v2/users")
public List<User> getAllUsersV2() {
    //

```
 
In this example, the URI path includes the version number (v1 and v2) to distinguish between different versions of the API.


**Version as a request parameter:** In this approach, the version number is included as a query parameter in the URI. For example:

```

@GetMapping("/users?version=1")
public List<User> getAllUsersV1() {
    // return all users for version 1
}
@GetMapping("/users?version=2")
public List<User> getAllUsersV2() {
    // return all users for version 2
}

```

In this example, the version number is passed as a query parameter in the URI. The handler methods can then use this parameter to determine which version of the API to use.

**Version as a request header:** In this approach, the version number is included as a custom request header. For example:

```

@GetMapping("/users")
public List<User> getAllUsers(@RequestHeader("X-Api-Version") String apiVersion) {
    if ("1".equals(apiVersion)) {
        // return all users for version 1
    } else if ("2".equals(apiVersion)) {  // return all users for version 2 }
      else {  throw new IllegalArgumentException("Unsupported API version");  }
}

```

In this example, the version number is passed as a custom request header (X-Api-Version). The handler method can then use this header to determine which version of the API to use.

**Accept Header Versioning approach** is one other way of versioning the API methods that insists the usage of Accept Header in the request.


## Q5. You have to retrieve some data from a database and expose the data using a GET endpoint to the client. What are the steps? What are the annotation we need to use? How can we paginate and sort those data?
To retrieve data from a database and expose it using a GET endpoint in a Spring REST application, you can follow these steps:

  - Define a model/entity class for the data you want to retrieve and annotate it with @Entity and @Table annotations to specify the corresponding database table.
  - Define a Spring Data JPA repository interface that extends the JpaRepository interface and provides the methods for retrieving data from the database.
  - Create a service interface and its implementation class that defines the methods for retrieving the data from the repository. Use the @Service annotation to mark the implementation class as a Spring bean.
  - Inject the repository interface into the service implementation class using the @Autowired annotation.
  - Define a method in the service implementation class that calls the repository method to retrieve the data and returns it as a List or a Page.
  - Create a Spring REST controller class and annotate it with @RestController to indicate that it will handle HTTP requests.
  - Inject the service interface into the controller using the @Autowired annotation.
  - Define a method in the controller class and annotate it with @GetMapping to specify the HTTP method and the endpoint URL. Inside the method, call the service method to retrieve the data and return it as the response body.
  - Optionally, you can add pagination and sorting to the endpoint by using the Pageable parameter in the controller method and passing it to the service method.
####
