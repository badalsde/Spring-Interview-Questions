<h1 Align="center">
  Request handling in REST Conceptual Questions
</h1>

## Q1. What are JAX-RS Annotations?
**@Path:** It is used to specify the relative path of a resource class or method.

for example, /helloworld. You can also embed variables in the URIs to make a URI path template. For example, you could ask for the name of a user and pass it to the application as a variable in the URI: /helloworld/{username}.

However, in Spring REST, the @Path annotation is not used. Instead, Spring REST uses the @RequestMapping annotation to map HTTP requests to handler methods.

**@Get:** It is a request method designator and corresponds to the similarly named HTTP method. The Java method annotated @Get will process HTTP GET requests.

**@Post:** It is a request method designator and corresponds to the similarly named HTTP method. The Java method annotated with @Post will process HTTP POST requests.

**@Put:** It is a request method designator and corresponds to the similarly named HTTP method. The Java method annotated with @Put will process HTTP PUT requests.

**@Produces:** It is used to specify the MIME media types or representations a resource can produce and send back to the client. If @Produces is applied at the class level, all the methods in a resource can produce the specified MIME types by default. If it is applied at the method level, it overrides any @Produces annotations applied at the class level.

If no methods in a resource are able to produce the MIME type in a client request, the Jersey runtime sends back an HTTP “406 Not Acceptable” error.

The value of @Produces is an array of String of MIME types.For example:

@Produces({"image/jpeg,image/png"})

**@Consumes:** It is used to specify which MIME media types of representations a resource can accept, or consume, from the client. If @Consumes is applied at the class level, all the response methods accept the specified MIME types by default. If @Consumes is applied at the method level, it overrides any @Consumes annotations applied at the class level.

If a resource is unable to consume the MIME type of a client request, the Jersey runtime sends back an HTTP “415 Unsupported Media Type” error.

The value of @Consumes is an array of String of acceptable MIME types. For example:

@Consumes({"text/plain,text/html"})


## Q2. What is the purpose of @RestController annotation?
- @RestController is an annotation in the Spring Framework that is used to define a class as a RESTful web service controller. It combines the @Controller and @ResponseBody annotations, making it easier to build RESTful web services.
- When a class is annotated with @RestController, it indicates that the class will handle incoming HTTP requests and generate the HTTP response. The methods within the class are typically annotated with HTTP method-specific annotations, such as @GetMapping, @PostMapping, @PutMapping, or @DeleteMapping, to specify the HTTP request method and URL mapping.
- The @ResponseBody annotation is automatically applied to all methods in the @RestController-annotated class. This means that the return value of each method is automatically serialized into the appropriate format (JSON, XML, etc.) and included in the HTTP response body.

For example, consider the following Spring controller class:

```

@RestController
@RequestMapping("/api")
public class MyController {
  @GetMapping("/greeting")
  public String greet() {
    return "Hello,World!";
  }
}

```

In this example, the @RestController annotation indicates that this class will handle incoming HTTP requests as a RESTful web service controller. The @RequestMapping annotation specifies the base URL for all endpoints in this class. The @GetMapping annotation specifies that the greet() method will handle GET requests to the /api/greeting URL path, and return the string "Hello, World!" as the response body.


## Q3. What is the difference between @Controller and @RestController
@Controller and @RestController are both annotations in Spring Framework that are used to handle HTTP requests, but there is a significant difference between the two.

**@Controller** is used to define a class as a Spring MVC controller, which is responsible for handling incoming HTTP requests and returning responses. The methods in a @Controller class can be annotated with @RequestMapping or any other request mapping annotations to map requests to the appropriate method.

**@RestController** is a specialized version of @Controller that is used for RESTful web services. It combines @Controller and @ResponseBody, which means that all methods in a @RestController class are automatically annotated with @ResponseBody. This annotation tells Spring MVC that the method's return value should be converted directly to JSON or XML and returned in the HTTP response body.

## Q4. What is @ResponseBody annotation?
- The @ResponseBody annotation in Spring REST is used to indicate that the return value of a method should be serialized directly into the response body of an HTTP response. When a method is annotated with @ResponseBody, Spring converts the return value of the method to a format that can be sent over the network, such as JSON or XML, and writes it directly to the HTTP response body.
- The purpose of using @ResponseBody is to simplify the process of building RESTful web services in Spring by eliminating the need to manually convert Java objects to a format that can be sent over the network. By using @ResponseBody, you can return a Java object directly from a controller method and let Spring handle the serialization process.
- Remember, we don't need to annotate the @RestController-annotated controllers with the @ResponseBody annotation since Spring does it by default.

For example, consider the following controller method:

```

@GetMapping("/users")
@ResponseBody
public List<User> getAllUsers() {
    List<User> users = userService.getAllUsers();
    return users;

```

In this example, the @GetMapping annotation maps the method to the /users endpoint, and the @ResponseBody annotation tells Spring to serialize the List<User> returned by the method and write it directly to the HTTP response body.

Without @ResponseBody, you would need to manually convert the List<User> to a format that can be sent over the network, such as JSON, using a library such as Jackson.


## Q5. How do we define controller path?
In the context of a Spring REST application, the controller path typically refers to the URL path that is mapped to a specific controller method.

When a REST client sends a request to the Spring application, the request is typically sent to a specific endpoint that is mapped to a controller method. The endpoint consists of a base URL, typically the domain name or IP address of the server hosting the application, and a path that identifies the specific controller and method to be invoked.

For example, consider the following controller method in a Spring REST application:

```

@RestController
@RequestMapping("/api")
public class MyController {
  @GetMapping("/greeting")
  public String greet() {
    return "Hello, World!";

```

In this example, the @RequestMapping annotation is used to specify the base URL for all the endpoints in this controller. The @GetMapping annotation is used to specify the HTTP method for the greet() method and the URL path that maps to it.

Thus, the controller path for this method would be /api/greeting, and a REST client would send a GET request to this URL to invoke the greet() method and receive the "Hello, World!" response.


## Q6. What is  the usage of @RequestBody annotation?
@RequestBody is an annotation that is used to bind the HTTP request body to a Java object. It is typically used in the parameter list of a controller method to extract the data sent by the client in the request body.

Here's an example of how to use @RequestBody in a Spring REST controller:

```

@RestController
public class MyController {
  @PostMapping("/users")
  public User createUser(@RequestBody User user) {
    // ... code to create user in database
    return user;
  }
}

```

The @RequestBody annotation on the user parameter indicates that the data sent in the request body should be mapped to a User object. Spring will automatically deserialize the JSON or XML data in the request body and create a User object based on the data.

The @RequestBody annotation can be used with any HTTP method that has a request body, such as POST, PUT, and PATCH. It can also be used with other data formats, such as form data, by specifying the appropriate media type in the consumes attribute of the @RequestMapping annotation.

Using @RequestBody, we can easily map complex data structures sent by the client to Java objects, which can then be used in your application logic.


## Q7. What is the DispatcherServlet in Spring?
The DispatcherServlet in Spring Boot acts as the front controller for handling web requests, leveraging auto-configuration and the embedded Servlet container to simplify the development process while still allowing customization when needed.  The DispatcherServlet in Spring Boot:
 

- Auto-configured and registered with the embedded Servlet container (Tomcat, Jetty, Undertow) automatically.
- Handles request mapping and dispatching to appropriate controllers using annotations like @RequestMapping, @GetMapping, etc.
- Resolves views returned by controllers using configured ViewResolvers.
- Handles exceptions through @ExceptionHandler methods and @ControllerAdvice.
- Provides auto-configuration for Servlet Filters and HandlerInterceptors.
- Eliminates need for separate web server deployment due to embedded Servlet container.
- Customizable behavior through properties or custom configuration classes.
 
