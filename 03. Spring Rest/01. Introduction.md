<h1 Align="center">
  Spring Rest Baics Conceptual Questions
</h1>

## Q1. What is Rest API?
- REST API stands for Representational State Transfer Application Programming Interface. It is a type of web service that allows communication between different software systems over the internet.
- It is based on the principles of the REST architectural style, which defines a set of constraints for creating scalable and maintainable web services.
- REST APIs use HTTP requests to retrieve and send data in a standardized format, such as JSON or XML. They are designed to be stateless, meaning that each request contains all the necessary information to complete the request, and the server does not store any session data between requests. REST APIs are widely used in web and mobile applications to access and manipulate data from remote servers.


## Q2. What are the HTTP verbs used in RESTful APIs?
REST API uses HTTP verbs or methods to indicate the type of operation that is being performed on a resource. The commonly used HTTP verbs in REST API are:
  - GET
  - POST
  - DELETE
  - PUT
  - PATCH

## Q3. What is the Difference between GET, POST and PUT?
The GET, POST, and PUT are HTTP methods that are used to interact with the resources exposed by a RESTful web service. Here are the main differences between these methods:

  - **GET:** The GET method is used to retrieve a representation of a resource. When a client sends a GET request to a RESTful API, the server responds with the current state of the resource identified by the URL in the request. GET requests should be used only for safe and idempotent operations, meaning that they do not modify the state of the resource.
  - **POST:** The POST method is used to create a new resource. When a client sends a POST request to a RESTful API, the server creates a new resource based on the request body and returns a URL that can be used to retrieve the newly created resource. POST requests are not idempotent, meaning that multiple requests with the same data may create multiple resources.
  - **PUT:** The PUT method is used to update an existing resource. When a client sends a PUT request to a RESTful API, the server updates the resource identified by the URL in the request with the data in the request body. PUT requests are idempotent, meaning that multiple requests with the same data will produce the same result.

In summary, GET requests should be used for retrieving resources, POST requests for creating new resources, and PUT requests for updating existing resources. It's important to note that these methods are just conventions and do not have any inherent security or validity checks. 


## Q4. What are the different layers of  a REST API  in Spring Boot Application?
In a typical Spring Boot application, the different layers of a REST API can be organized into the following components:
  - Controller layer
  - Service layer
  - Data access layer:
  - Domain layer


## Q5. Why do we define an Interface for Service layer?
Creating an interface between the controller and service layer is a common practice in software development, and it has several benefits:

- **Loose coupling:** By defining an interface for the service layer and injecting it into the controller, we can decouple the controller from the implementation of the service layer. This makes it easier to swap out the implementation of the service layer, for example, to switch from an in-memory implementation to a database-backed implementation.
- **Testability:** By defining an interface for the service layer, we can create mock implementations of the service layer for testing purposes. This allows us to test the controller in isolation from the service layer.
- **Code maintainability:** By separating the concerns of the controller and service layer into separate classes and interfaces, we can make our code more modular and easier to maintain.

## Q6. What value does Spring Boot Actuator provide?
Spring Boot actuator allows you to monitor and manage applications usage in production env.

These monitoring information is exposed over JMX and  HTTP.

HTTP endpoints expose  REST like URLs.

Some of the endpoints are

1. /health :shows application health infromation
2. /info: Displays application information, Can configure this in Spring environment properties.
3. /mappings: Displays the list of all @RequestMapping paths.
4. /shutdown: allows to gracefully shutdown the application.
5. /threaddump: provides the thread dump of the application.


## Q7. How to enable actuator support in a Spring Boot application?
To get actuator support 

Step:1 add the below dependency in a Spring Boot application

```
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
```

**Note:** By default, only the health endpoint is exposed over HTTP and JMX

Step 2 : An endpoint is considered to be available when it is both enabled and exposed .

To enable the below properties can be used

```

management.endpoint.<id>.enabled
eg:
# to expose info endpoint use the below property
management.endpoint.info.enabled=true
or
# Expose all the properties using
management.endpoints.enabled-by-default=true

``` 

You can expose the endpoints using exclude/include  properties as shown below

```

management.endpoints.web.exposure.exclude=
    or
management.endpoints.web.exposure.include=

```

```

eg:
#enabling beans and info
management.endpoints.web.exposure.include=beans,info
#enabling all endpoints
management.endpoints.web.exposure.include=*
 
```

Step 3:To access the endpoint over http, you will have to  map the ID of the endpoint  and add a prefix /actuator to the base URL

```
eg:/actuator/health

```

**Note:** An endpoint is considered to be available when it is both enabled and exposed


## Q8. Are you able to change the server or server type in a Spring Boot application?
Yes, it is possible to change the server or server type in a Spring Boot application. By default, Spring Boot uses the Tomcat server as the embedded servlet container, but you can switch to a different server or server type if needed.
To change the server or server type, you need to exclude the default Tomcat dependency and include the dependency for the desired server. Below is an example of how to switch to the Jetty server:

1. In your project's pom.xml file (for Maven) ,Locate the spring-boot-starter-web dependency, which includes the embedded Tomcat server and exclude the Tomcat dependency from the spring-boot-starter-web dependency.

```

<dependency>
   <groupId>org.springframework.boot</groupId>
   <artifactId>spring-boot-starter-web</artifactId>
   <exclusions>
       <exclusion>           		         	<groupId>org.springframework.boot</groupId>
           <artifactId>spring-boot-starter-tomcat</artifactId>
       </exclusion>
   </exclusions>
</dependency>

```

2. Add the Jetty server dependency.
 
```

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-jetty</artifactId>
</dependency>

```

3. Save and Restart your Spring Boot application, and it will now use the Jetty server instead of Tomcat.


## Q9. What are the annotations used in a Controller class?
In Spring Boot, the annotations used in a Controller class are mostly the same as in Spring MVC, with a few additions. Here are the commonly used annotations in Spring Boot Controller classes:

- **@RestController:** Combines @Controller and @ResponseBody, making it easier to create RESTful web services that automatically serialize the response as JSON or XML.
- **@RequestMapping, @GetMapping, @PostMapping, @PutMapping, @DeleteMapping:** Used for mapping HTTP requests to specific handler methods.
- **@PathVariable:** Binds a value from the URI path to a method argument
- **@RequestParam:** Binds a request parameter value to a method argument.
- **@RequestBody:** Binds the HTTP request body to a method argument, typically used for handling JSON or XML data.
- **@ResponseStatus:** Specifies the HTTP status code that should be returned for a specific exception or method.
- **@CrossOrigin:** Handles cross-origin resource sharing (CORS) in RESTful web services.
- **@Validated:** Used in conjunction with Bean Validation annotations (e.g., @NotNull, @Size) to automatically validate method arguments.
- **@ExceptionHandler:** Defines methods that should handle specific exceptions thrown during request handling.
- **@ControllerAdvice:** Defines global exception handlers and other shared components across multiple controllers.
- **@Value:** Injects values from property sources (e.g., application.properties) into fields or method arguments.
- **@Autowired:** is used for automatic dependency injection, allowing Spring to automatically resolve and inject required dependencies into a class or member variable.


## Q10. What are the valid return types of the Controller object? 
The valid return types of the Controller object are:

- **String:** Returns a logical view name to be resolved and rendered by the DispatcherServlet.
- **void:** Used for handling HTTP response directly, without returning any value from the method.
- **ModelAndView:** Encapsulates both the model data and the view name for rendering.
- **Model:** Used to pass data to the view for rendering, typically used with @ModelAttribute.
- **@ResponseBody:** Annotated method returns the response body directly as the HTTP response, bypassing view resolution.
- **HttpEntity<?> :** Returns the entire HTTP response, including headers and body, providing full control over the response.
- **ResponseEntity<?> :** Similar to HttpEntity, but with additional support for setting HTTP status codes.
- **DeferredResult<?> :** Used for asynchronous request processing, allowing the response to be produced later, after some processing.
- **HttpHeaders:** Returns the HTTP headers to be included in the response.
- **ErrorResponse:** Represents an error response, typically used for handling exceptions.
- **Map:** Can return a Map object to be used as the model for rendering the view.
