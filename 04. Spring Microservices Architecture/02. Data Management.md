<h1 align="center">
  Data Management Conceptual Questions
</h1>

## Q1. How to implement distributed operations when each service has its own database
Distributed operations can be implemented in following ways when each service has its own database
- SAGA
- API composition
- CQRS

## Q2. Explain Saga Pattern
- Saga is used to implement transactions that span services
- A saga is a sequence of local transactions.
- Each local transaction updates the database and publishes a message or event to trigger the next local transaction in the saga.

<img src="https://github.com/badalsde/Spring-Interview-Questions/tree/main/Images/ms1.png" alt="Microservices-1" width="800" />

- If a local transaction fails because it violates a business rule then the saga executes a series of compensating transactions that undo the changes that were made by the preceding local transactions.

Below is an example to understand the flow.

- Imagine that you are building an e-commerce store where customers have a credit limit. The application must ensure that a new order will not exceed the customer’s credit limit. Since Orders and Customers are in different databases owned by different services the application cannot simply use a local ACID transaction.

Saga can be implemented in 2 ways:

**Choreography-based saga:**

An e-commerce application that uses this approach would create an order using a choreography-based saga that consists of the following steps:

- The Order Service receives the POST /orders request and creates an Order in a PENDING state
- It then emits an Order Created event
- The Customer Service’s event handler attempts to reserve credit
- It then emits an event indicating the outcome
- The OrderService’s event handler either approves or rejects the Order
  
 
<img src="https://github.com/badalsde/Spring-Interview-Questions/tree/main/Images/ms2.png" alt="Microservices-2" width="800" />

 
**Orchestration-based saga:**

An e-commerce application that uses this approach would create an order using an orchestration-based saga that consists of the following steps:

- The Order Service receives the POST /orders request and creates the Create Order saga orchestrator
- The saga orchestrator creates an Order in the PENDING state
- It then sends a Reserve Credit command to the Customer Service
- The Customer Service attempts to reserve credit
- It then sends back a reply message indicating the outcome
- The saga orchestrator either approves or rejects the Order
 

<img src="https://github.com/badalsde/Spring-Interview-Questions/tree/main/Images/ms3.png" alt="Microservices-3" width="800" />
 

## Q3. Explain Command Query Responsibility Segregation (CQRS)
Command Query Responsibility Segregation( CQRS) pattern can be used when there is a  need to implement a query that retrieves data from multiple services in a microservice architecture

In CQRS ,we define a view database, which is a read-only replica that is designed to support that query. The application keeps the replica up to date by subscribing to Domain Events published by the service that own the data.

<img src="https://github.com/badalsde/Spring-Interview-Questions/tree/main/Images/ms4.png" alt="Microservices-4" width="800" />

This pattern has the following drawbacks:

- Increased complexity
- Potential code duplication
- Replication lag/eventually consistent views

## Q4. What is API Composition
API composition pattern can be used to implement queries that join data from multiple services.

<img src="https://github.com/badalsde/Spring-Interview-Questions/tree/main/Images/ms5.png" alt="Microservices-5" width="800" />

This pattern has the following drawbacks:

- Some queries would result in inefficient, in-memory joins of large datasets.

## Q5. Explain Database per service
- The service’s database is effectively part of the implementation of that service.
- It cannot be accessed directly by other service
- Database per service is a database architecture in a microservices application
- The service’s database is always part of the implementation of that service. It cannot be accessed directly by other services.
- There are a few different ways to keep a service’s persistent data private.
- There is no  need to provision a database server for each service.
- For example, if you are using a relational database then the options are:
  - Private-tables-per-service – each service owns a set of tables that must only be accessed by that service
  - Schema-per-service – each service has a database schema that’s private to that service
  - Database-server-per-service – each service has it’s own database server.
