<h1 align="center">
  Annotations in SpringBoot Conceptual Questions
</h1>


## Q1. How to create a bean in Spring boot?
In Spring Boot, we can create a bean in below twoways.

#### Using @Component annotation:

- Define the Bean: Define a class for the bean you want to create. This class should have the properties and methods you need for your application.
- Annotate the Bean: Use the @Component annotation to indicate that the class is a bean.

```

@Component
public class MyBean { 
//... 
}

```

- Using @Bean annotation: We can use the @Bean annotation in a configuration class to define a bean.

```

@Configuration
public class MyConfiguration {
   @Bean
   public MyBean myBean() {
      return new MyBean();
   }
}

```

## Q2. What is the difference between @Component, @Service and @Repository annotations?
In Spring framework, @Component, @Service and @Repository annotations are used as stereotypes for declaring beans. All these annotations serve as markers that inform the Spring framework to create and manage the corresponding beans.

The main difference between them is in their intended use and semantics.

- **@Component** is a generic stereotype annotation and can be used to annotate any Spring-managed bean.
- **@Service** is a more specific annotation and is typically used to annotate a class that represents a service in the business layer of an application.
- Similarly, **@Repository** is used to annotate a bean that contain Operations related to database.
- Additionally, **@Controller** or the **@RestController** annotations are used to mark classes as a request handler to allow Spring to recognize it as a RESTful service during runtime.


## Q3. What does the @SpringBootApplication annotation encapsulates?
The @SpringBootApplication annotation in Java encapsulates three annotations: @Configuration, @EnableAutoConfiguration, and @ComponentScan.

Here's what each of these annotations does:

- **@Configuration:** Indicates that the class is a configuration class that defines beans. This annotation is used along with @Bean annotations to define Spring beans.
- **@EnableAutoConfiguration:** Tells Spring to automatically configure the application based on its classpath and the beans defined in its context. This includes configuring database connections, setting up the web environment, and other common configurations.
- **@ComponentScan:** Scans the specified package and its sub-packages for Spring components and services. This is required to find and load all the components and services that are needed by the application.


## Q4. What is the @Configuration annotation in Spring?
- The @Configuration annotation is used to indicate that a class is a configuration class that defines one or more Spring beans. A configuration class contains methods that define Spring beans using the @Bean annotation.
- When Spring's container scans the application for beans, it looks for classes that are annotated with @Configuration. Once it finds such a class, it reads the @Bean methods in that class and creates instances of the beans they define.

Here's an example of a simple @Configuration class:

```

@Configuration
public class MyConfig { @Bean
  public MyService myService() {
  return new MyServiceImpl();
  	}
  }

 ```

## Q5. What is @Autowired annotation?
- @Autowired is an annotation in the Spring Framework used for automatic dependency injection.
- When Spring creates an object of a class that has an @Autowired annotation, it will automatically search for a matching dependency to inject into that object.
- @Autowired annotation perform byType Autowiring i.e. dependency is injected based on bean type
- @Autowired cannot be used for primitive values.
- This annotation can be used at the property, setter method, or constructor level.

We will use @Autowired in the below code to wire the dependency of ReportService class for ReportGenerator bean dependency.

```

public class ReportService {
@Autowired
private ReportGenerator report;
//--------------------
}

```

## Q6. How to disable the AutoConfiguration in springboot for some classes?
To disable auto-configuration for specific classes in Spring Boot, we can use the @EnableAutoconfiguration annotation with the ‘exclude’ pattern.

```

@Configuration
@EnableAutoConfiguration(exclude = { MyAutoConfiguration.class })
public class MyApplication {
  public static void main(String[] args) {
    SpringApplication.run(MyApplication.class, args);
  }
}

```

In this example, **‘MyAutoConfiguration’** class will be excluded from auto-configuration. We can list multiple classes to exclude by separating them with commas inside the curly braces.


## Q7. What is the use of @Qualifier Annotation?
The **‘Qualifier’** annotation in Spring is used to disambiguate bean dependencies when there are multiple beans of the same type defined in the application context. It tells Spring which bean to inject by specifying the bean name or qualifier value.

```

public class OrderFacade
{
  @Qualifier("userServiceImpl")
  @Autowired
  private UserService userService;
}

```

## Q8. How does the @AutoConfiguration annotation work in Spring Boot?
The @AutoConfiguration annotation is a core feature of Spring Boot that enables automatic configuration of the application based on the project's dependencies and the components present on the classpath. 

It works as follows:

- Spring Boot scans the classpath for classes annotated with @Configuration and @AutoConfiguration.
- Based on the dependencies and components detected on the classpath, Spring Boot automatically creates and registers the relevant configuration beans defined in the @AutoConfiguration classes.
- This process eliminates the need for developers to define standard configurations manually, allowing them to focus on writing application-specific code.
- If required, developers can override or extend the auto-configured beans by providing their own configuration classes, which take precedence over the auto-configurations.


## Q9. What are some of the most commonly used Spring Boot annotations, and briefly explain their purposes?
- @SpringBootApplication: Combines @Configuration, @EnableAutoConfiguration, and @ComponentScan annotations, enabling auto-configuration, defining bean configurations, and component scanning.
- @RestController: Marks a class as a controller that handles RESTful web service requests.
- @RequestMapping: Maps web requests to handler methods in the controller class.
- @Service: Indicates that a class represents a service layer component in the application.
- @Repository: Marks a class as a repository component, typically for database access.
- @Value: Injects property values from configuration files into fields or method arguments.
- @Autowired: Injects dependencies (beans) into a class or field.
- @Qualifier: It is used to disambiguate between multiple bean instances of the same type when autowiring dependencies.


## Q10. How can you control the order in which multiple @Configuration classes are loaded and processed in a Spring Boot application, and why might you need to do that?
In a Spring Boot application, you can control the order in which multiple @Configuration classes are loaded and processed by using the @Order annotation.This is useful when you have configuration classes that depend on the order in which they are loaded or when you need to ensure that certain configurations are applied before others.

  - You can annotate your @Configuration classes with @Order and specify an integer value representing the order.
  - Lower values have higher precedence, and the configurations are loaded in ascending order of their @Order values.
  - For example, if you have two configuration classes ConfigA and ConfigB, annotating ConfigA with @Order(1) and ConfigB with @Order(2) will ensure that ConfigA is loaded before ConfigB.
 
```

@Configuration
@Order(1)
public class ConfigA {
    // Configuration beans and methods
}
@Configuration
@Order(2)
public class ConfigB {
    // Configuration beans and methods
}

```
