<h1 align="center">
 IOC and Dependency Injection Conceptual Questions
</h1>

## Q1. What is an IOC Container?
- In Spring, an IOC (Inversion of Control) Container is a software component that manages the instantiation and lifecycle of objects (or beans) in an application.
- The IOC container achieves this by creating a centralized registry of objects, and it's responsible for instantiating, configuring, and assembling these objects.
- The Spring IOC container works by using a technique called Dependency Injection.
- The benefits of using the Spring IOC container include loose coupling between objects, easier testing, and increased flexibility and scalability of the application.

Spring provides two types of containers

  #### BeanFactory:
  - org.springframework.beans.factory.BeanFactory is the main interface representing a BeanFactory container.

  #### ApplicationContext:
  - org.springframework.context.ApplicationContext is the main Interface representing an ApplicationContext container. 
  - It inherits the BeanFactory features and provides added features to support enterprise services such as internationalization, validation, etc.


## Q2. What is Dependency Injection? What are the types of Dependency Injection?
- Dependency Injection is the main functionality provided by Spring IOC(Inversion of Control).
- Dependency Injection provides better software design to facilitate loose coupling, reuse, and ease of testing.
- The Spring-Core module is responsible for injecting dependencies through either Constructor or Setter methods. 
- The design principle of Inversion of Control emphasizes keeping the Java classes independent of each other and the container frees them from object creation and maintenance. 
- It allows to replace actual objects with mock objects for testing, this improves testability by writing simple JUnit tests that use mock objects.

#### Need for Dependency Injection:

- Suppose class One needs the object of class Two to instantiate or operate a method, then class One is said to be dependent on class Two. Now though it might appear okay to depend a module on the other but, in the real world, this could lead to a lot of problems, including system failure. Hence such dependencies need to be avoided.
- Spring IOC resolves such dependencies with Dependency Injection, which makes the code easier to test and reuse. Loose coupling between classes can be possible by defining interfaces for common functionality and the injector will instantiate the objects of required implementation. The task of instantiating objects is done by the container according to the configurations specified by the developer.

#### There are three types of Dependency Injection in Spring:

- **Constructor Injection:** In this type of injection, dependencies are injected through the constructor of the object. This is the most commonly used type of injection in Spring.
- **Setter Injection:** In this type of injection, dependencies are injected through setter methods of the object. This type of injection is less common than constructor injection but is still widely used in some cases.
- **Field Injection:** In this type of injection, dependencies are injected directly into the fields of the object.


## Q3. How does Spring Field Dependency Injection work?
- @Autowired is an annotation in the Spring Framework used for automatic dependency injection.
- When Spring creates an object of a class that has an @Autowired annotation, it will automatically search for a matching dependency to inject into that object.
- @Autowired annotation perform byType Autowiring i.e. dependency is injected based on bean type
- @Autowired cannot be used for primitive values.
- This annotation can be used at the property, setter method, or constructor level.

We will use @Autowired in the below code to wire the dependency of ReportService class for ReportGenerator bean dependency.

```

public class ReportService {
@Autowired
private ReportGenerator report;
//--------------------
}

```

## Q4. What is lazy initialization in Spring Boot?
- In Spring, lazy loading (also known as lazy initialization) is a technique used to defer the initialization of an object until it is needed. This can improve the performance of an application by reducing the number of resources used to initialize objects that are not immediately necessary.
- When an object is marked as lazy-initialized, Spring will not create the object until it is actually needed. For example, if an object is injected into another object but is never used, Spring will not create the object at all. If the object is later used, Spring will create the object at that time.
- Lazy loading can be beneficial in cases where objects are expensive to create or where there are many objects that may not all be needed at the same time. However, it is important to carefully consider the use of lazy loading, as it can also introduce additional complexity and potential issues such as concurrency problems.
- Spring Boot 2 introduces the spring.main.lazy-initialization property, making it easier to configure lazy initialization across the whole application.
- We have to set as below in application.properties

```

spring.main.lazy-initialization=true

```

- This configuration affects all the beans in the context. So, if we want to configure lazy initialization for a specific bean, we can do it through the @Lazy Annotations

```
@Bean
@Lazy(true)
public Region getRegion(){
return new Region(); }

```

- Overall, lazy loading can be a useful technique in certain situations, but it is important to weigh the benefits against the potential drawbacks and carefully consider whether it is appropriate for your specific application.


## Q5. Who manages the lifecycle of a bean?
The Spring IoC container manages the lifecycle of a bean, including instantiation, dependency injection, initialization, use, and destruction. The container provides features like bean scopes and callbacks to control the bean lifecycle and ensure that dependencies are correctly managed.


## Q6. Which is the better approach among XML and Annotation to implement the IOC?
- Both XML-based and annotation-based configuration have their own advantages and disadvantages. Ultimately, the choice between the two depends on the personal preference and the specific requirements of project.
- XML-based configuration has been the traditional way of configuring Spring applications. It provides a clear separation of concerns between configuration and code, making it easy to manage and maintain large configurations. It also provides a high level of flexibility and allows for the configuration of complex object graphs and cross-cutting concerns such as AOP.
- On the other hand, annotation-based configuration provides a more concise and readable way of configuring Spring applications. It reduces the amount of boilerplate code required to configure a Spring application and makes it easier to understand the relationships between different components. Additionally, it enables developers to use annotations to express the intent of their code, making it more expressive and easier to read.
- In recent years, there has been a trend towards using annotation-based configuration, as it provides a more modern and lightweight approach. However, XML-based configuration is still widely used, especially in large enterprise applications, where the ability to manage and maintain complex configurations is critical.


## Q7. Give some simple real-life examples of Dependency Injection?
Some simple real-life examples of Dependency Injection are as follows:

- Online Shopping and Payment Gateway:
 - The e-commerce website (object) needs a payment gateway (dependency) to process payments
 - The website integrates with a third-party payment gateway service (external source) to handle transactions
 
- A car being fueled at a gas station:
 - The car (object) depends on the fuel (dependency)
 - The gas station (external source) injects the fuel into the car
 
- Television and Remote Control:
 - The television (object) needs a remote control (dependency) to operate
 - The TV manufacturer (external source) provides the remote control with the TV


## Q8. Difference between Spring IOC and dependency injection
| Aspect | Spring IoC | Dependency Injection |
|--------|------------|----------------------|
| Definition | Inversion of Control (IoC) is a design principle where the control flow of a program is inverted. Instead of an object creating its dependencies, the dependencies are provided to the object from an external source. | Dependency Injection (DI) is a design pattern that implements the IoC principle. It is a way to achieve loose coupling between objects and their dependencies. |
| Role | IoC is a broader concept that defines the principle of inverting the control flow. | DI is a specific implementation technique that follows the IoC principle. |
| Implementation  | Spring IoC container manages the lifecycle of objects and injects dependencies into them. | DI is implemented by injecting dependencies into objects using constructor injection, setter injection, or interface injection. |
| Purpose | The primary purpose of IoC is to decouple the execution of a task from the implementation. | The main purpose of DI is to achieve loose coupling between objects and their dependencies, making the code more modular, testable, and maintainable. |
| Scope | IoC encompasses the entire process of creating and managing objects, including dependency injection. | DI is a specific way to resolve dependencies between objects. |
| Example | The Spring IoC container is an example of an IoC container that manages the creation and lifecycle of objects. The BeanFactory is the most basic version of IoC containers, and the ApplicationContext extends the features of BeanFactory. | Constructor injection, where dependencies are injected through the constructor, is an example of DI. |


## Q9. Difference between BeanFactory and ApplicationContext
Two main Core Interfaces of Spring IOC Container:

 - Bean Factory
 - Application Context
 
Below table describes the difference between the two containers.

| BeanFactory | ApplicationContext |
|-------------|--------------------|
| Root interface for accessing spring beans | This central interface extends BeanFactory adding additional functionalities |
| By default, supports Lazy loading	| By default, supports Eager loading |
| Does not support annotation-based Dependency Injection | Supports annotation-based Dependency Injection |
| Not commonly used | Commonly used | 
