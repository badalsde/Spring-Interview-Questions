<h1 align="center">
  Transactions Conceptual Questions
</h1>

## Q1. How are transactions managed in Spring?
A transaction is a sequence of   operations performed on a database, and all treated as a single logical unit of work â€” taking place wholly or not at all

Transaction management in Spring can be done either declaratively or programmatically 

- **Declarative Transaction:** Spring applies the required transaction to the application code in a declarative way using a simple configuration. Spring internally uses Spring AOP to provide transaction logic to the application code. This is implemented using either pure XML configuration or @Transactional annotation approach.

- **Programmatic Transaction:** The required transaction is achieved by adding transaction-related code in the application code. This approach is used for more fine level control of transaction requirements. This mixes the transaction functionality with the business logic and hence it is recommended to use only based on the need. This is implemented using either TransactionTemplate (adopts the same approach as JdbcTemplate) or a PlatformTransactionManager implementation.


## Q2. User screen has list of 200 items with checkbox each, user checks some 101 checkbox items and submit order, It is saved in DB. Next day user come back and select another 50 items and submit the order but then realize that he was not supposed to select 1 item out of that 50 and wanted to update the order but here this transaction has been committed already then how we can bring back and show the user with original selections and allow user to re-edit to submit?
No, you can't undo, rollback or reverse a commit.<br>
But you can re-fetch the the items selected and display as checkboxes , make changes and update the database accordingly.

Alternatively,there can also be an  intermediate Confirmation process which enables User to confirm the products he has added to the order. Once he confirms the order, then it is actually updated in the db.


## Q3. How do we load repositories package in JPA to manage conflicts?
 

In order to let spring knows what DataSource is related to what Repository you should define it at the @EnableJpaRepositories annotation. Let's assume that we have two entities, the Servers entity and the Domains entity and each one has its own Repo then each Repository has its own JPA DataSource configuration.
- Group all the repositories based on the DataSource that they are related to in a separate package.
- For each JPA DataSource, define a configuration.
- Set one Datasource as primary.


## Q4. Will transaction roll back for checked exceptions in a transactional method?
Roll back for checked exception don't happen by default.

To achieve roll back for checked exception we will need to specify it using rollbackfor attribute in @Transactional annotation

```

  @Transactional( rollbackFor = SomeCheckedException.class)
  public void createProduct() throws Exception{ 
  ....
  throw new SomeCheckedException();
}

```

## Q5. Look at the code snippet below and answer the below question. Will the record be inserted into the database if insertCustomer is called by passing a valid customerDTO object?
``` 
@Override
  @Transactional()
  public void insertCustomer(CustomerDTO customerDTO) throws SQLException {
	  Customer cust=CustomerDTO.prepareCustomerEntity(customerDTO);
	  cust.setStatus("With RuntimeException-No Rollback");
	  repository.save(cust); 
	  System.out.println("Customer inserted.");
	  throw new SQLException();
  }
 
```
<hr>

Yes, the record will get inserted into the DB 

As you are aware Spring Transaction will be started and committed after the code has been executed errorless. Otherwise, it will roll back the changes if an exception occurred.

But in this case the rollback does not happen as Spring only rolls back on unchecked exceptions by default.

If the provided code has to rollback for any checked exceptions then use the rollbackfor attribute  as shown below

```
  @Override
  @Transactional(rollbackFor  = SQLException.class)
  public void insertCustomer(CustomerDTO customerDTO) throws SQLException {
	  Customer cust=CustomerDTO.prepareCustomerEntity(customerDTO);
	  cust.setStatus("With RuntimeException-No Rollback");
	  repository.save(cust); 
	  System.out.println("Customer inserted.");
	  throw new SQLException();
  }

  ```

## Q6. Look at the code snippet below Will the record be inserted into the database if insertCustomer() is called by passing a valid customerDTO object?

```
 @Override
 @Transactional()
 public void insertCustomer(CustomerDTO customerDTO)   {
      Customer cust=CustomerDTO.prepareCustomerEntity(customerDTO);
      cust.setStatus("With NullPointer");
      repository.save(cust); 
      System.out.println("Customer inserted.");
      try {
      throw new NullPointerException();}
      catch(Exception e) {System.out.println("caught exception");}
 }
 ```
<hr>

 Yes, the transaction will be executed normally and committed as we manually caught the exception and handled it.  
