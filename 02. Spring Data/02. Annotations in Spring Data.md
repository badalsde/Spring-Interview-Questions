<h1 align="center">
  Annotations in Spring Data Conceptual Questions
</h1>

## Q1. What is the use of the @Entity annotation in Spring Boot?
- @Entity annotation is used for declaring any POJO class as an entity for a database.
- This annotation can be applied on Class, Interface or Enums.
- Its a JPA (Java Persistence API now called as Jakarta Persistence API) annotation. JPA is an ORM specification in Java  for relational data management  .
- Spring Data JPA provides repository support for the Jakarta Persistence API (JPA).


## Q2. What are the common annotations used in the DAO layer of a Spring Boot application?
**@Repository:** @Repository annotation can be used at the user-defined interface as Spring provides repository implementation of this interface.

**@Entity:**  Defines a class as mapped to a database table in a relational database.

**@NamedQuery:** Enable you to declare a query in your persistence layer and reference it in your business code.

**@Query:** Helps in execution of both JPQL and native SQL queries.

**@Transactional:** Used on define methods that are required to be executed in the transaction scope.

**@Modifying:** This annotation triggers the query annotated to a particular method as an updating query instead of a selecting query.


## Q3.  How do you generate sequence for your primary key?
Primary Key Generation strategies:

Identifiers represent the primary key of an entity and they uniquely identify each entity 

There are 2 ways to use identities in JPA,

- Simple identifiers(mapped to single DB column acting as primary key)
- Composite identifiers (multiple columns together to act as primary key)

To mark a single field as primary key @Id annotation has to be used as shown below

```

@Id
private Integer id;

```

To autogenerate the primary key value

```
 @Id
 @GeneratedValue
 private Integer id;
 
```

GeneratedValue annotation with @Id on any field specifies that values will be autogenerated for that field. 

This can use four generation types: 

- AUTO
- IDENTITY 
- SEQUENCE 
- TABLE

**Note:** AUTO is the default generation type and lets the persistence provider choose the generation strategy

#### Explanation for each strategy

**AUTO:** GenerationType.AUTO is the default strategy. This lets the JPA implementor  choose the best strategy(eg Hibernate  chooses the best strategy based on the database dialect). 

```

@Id
@GeneratedValue(strategy = GenerationType.AUTO)
private Integer id;

```

**IDENTITY:** GenerationType.IDENTITY lets the database to generate this value, mostly by an auto-increment logic

```

@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
private Integer id;

```

**SEQUENCE:** GenerationType.SEQUENCE is the advised way to generate primary key values and hibernate uses a database sequence to generate unique values.

```

@Id
@GeneratedValue(strategy = GenerationType.SEQUENCE)
private Integer id;

```
The GenerationType.SEQUENCE requires additional select statements to get the next value from a database sequence. 

**NOTE:** Additionally, you can pass a @SequenceGenerator reference in the @GeneratedValue configuration. The @SequenceGenerator annotation lets you define the name of the database-sequenceName, the generator name, the schema of the database sequence, and the allocation size of the sequence.

```

@Id
@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "inst_seq")
@SequenceGenerator(name = "inst_seq", sequenceName = "emp_seq", 
initialValue = 1,
allocationSize=50))
private Integer id;

```
**Note:** The above parameter @SequenceGenerator will create a sequence which starts with 1 and incremented by 50. It means that it will do only one query for the next value of the sequence and it will be used for the next 50.

**TABLE:** GenerationType.TABLE is rarely used today. It simulates a sequence by storing and updating its current value in a database table.

```
@GeneratedValue(generator = "table", strategy=GenerationType.TABLE)
@Id
private Long id;

```

## Q4. How do you map one-many relationships and on which field?
- One-to-many mapping means that one row in a table is mapped to multiple rows in another table.
- The way we do it in code is with @OneToMany.
- For example, a Cart has many Items.

```

  public class Cart
  {
    @OneToMany(mappedBy="cart")
    private Set<Item> items;
  }

```

- We can also add a reference to Cart in each Item using @ManyToOne, making this a bidirectional relationship. Bidirectional means that items can be accessed from carts, and carts from items.
- The mappedBy property tells Hibernate which variable is being used to represent the parent class in the child class.


## Q5. How do you handle and define DataSources when two database (Oracle, DB2) need to be connected in Spring Boot? (Spring by default allows only one DataSource object to be created)
- The typical scenario for a Spring Boot application is to store data in a single relational database. But we sometimes need to access multiple databases.
- To configure multiple data sources, create as many bean definitions as you want but mark one of the DataSource instances as @Primary.
- Remember that if we create our own DataSource bean then auto-configuration backs off. In this case, we are responsible for providing configurations for all datasource beans.
- While autowiring the datasource, spring boot will prefer the primary datasource. To autowire another non-primary datasource, use @Qualifier annotation.
