<h1 align="center">
  Spring Data Basics Conceptual Questions
</h1>

## Q1. Can you print the SQL statement of the database operations generated by Spring data JPA and hibernate  in a Spring Boot application?
- The simplest way to dump the queries to standard out is to add the following to application.properties:

   `spring.jpa.show-sql=true`
  
- We can also log the SQL statements by configuring loggers in the properties file:

   `logging.level.org.hibernate.SQL=DEBUG` <br>
   `logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE`
  
- Here, the first line logs the SQL queries, and the second statement logs the prepared statement parameters.


## Q2. How do we create Hibernate mappings?
**Using xml file**

```

<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE hibernate-mapping PUBLIC
   "-//Hibernate/Hibernate Mapping DTD//EN"
   "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd">
<hibernate-mapping default-access="field">
   <class name="Sample">
      <id type="int" column="id">
         <generator class="native"/>
      </id>
      <property name="name" type="string"/>
   </class>
</hibernate-mapping>

```

**Using Annotations**

```

import javax.persistence.* ;
@Entity
public class Sample
{
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    public Integer id;
    public String name;
}

```

Maintaining the mapping information as external XML files allows that mapping information to be modified to reflect business changes or schema alterations without forcing us to rebuild the application. But annotations-based mappings are far more intuitive than their XML-based alternatives, as they are immediately in the source code along with the properties with which they are associated.


## Q3. In a table with 20 different columns and 100 million rows, if the user tries to search for a record with some value, then there could be an issue with performance. How would you handle this, what is your approach and what all needs to be done to have good performance?
- **Indexing:** Depending on the type of data and the searchable fields, indexing should be applied to the table. Indexing should be based on the query frequency, the data type and the size of the table.
- **Partitioning:** This helps to logically split the table into smaller chunks, so instead of searching the entire 100 million rows, the query can be limited to a specific partition.
- **Caching:** Caching the data in memory can further improve the query performance.
- **Database Tuning:** Tuning the database parameters and settings such as query optimizer and buffer pool size can also help to improve the performance.
- **Query Optimization:** Writing optimized queries and using the right query language can help reduce the query execution time.
- **Denormalization:** Denormalizing the table can help reduce redundant data and increase query performance.
- Additionally having  **Hardware Resources**(CPU, Memory, Storage) for supporting the complex and resource intensive queries
